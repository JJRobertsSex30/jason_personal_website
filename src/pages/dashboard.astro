---
import Layout from '~/layouts/PageLayout.astro';
import { supabase } from '~/lib/supabaseClient';
import type { Session } from '@supabase/supabase-js';
import ABTestManager from '~/components/widgets/ABTestManager.astro';
import UserProfileManager from '~/components/widgets/UserProfileManager.astro';

// Define a basic UserProfile type.
export interface UserProfile {
  id: string;
  username?: string;
  full_name?: string;
  website?: string;
  email?: string; // Added email as it's used in UserProfileManager
  created_at?: string | null; // Added based on UserProfileManager usage
  updated_at?: string | null; // Added based on UserProfileManager usage
  [key: string]: unknown; 
}

// Interfaces for A/B Testing
export interface VariantConfig {
  [key: string]: unknown; // Can be more specific later
}

export interface Variant {
  id: string; // UUID
  experiment_id: string; // UUID
  name: string;
  description?: string | null;
  config_json?: VariantConfig | null;
  created_at: string; // Timestamptz
  updated_at: string; // Timestamptz
  impressions_count?: number;
  conversions_count?: number;
  conversion_rate?: number; 
}

export interface Experiment {
  id: string; // UUID
  name: string;
  description?: string | null;
  is_active: boolean;
  created_at: string; // Timestamptz
  updated_at: string; // Timestamptz
  variants?: Variant[];
  // UI helper, not from DB
  managingVariants?: boolean; 
  variantsJsonString?: string; // New property for pre-stringified variant data for charts
}

const metadata = {
  title: 'Admin Dashboard', // Updated title
  description: 'Manage A/B Tests and view user profiles.', // Updated description
};

let userProfiles: UserProfile[] | null = null;
let pageError: string | null = null; // Renamed global error to avoid conflict with component prop name
let session: Session | null = null;
let experiments: Experiment[] | null = null;
let abTestError: string | null = null;
let generalMessage: string | null = null; // For general messages like login success

// Helper function to fetch experiments with their stats
async function fetchExperimentsWithStats(openExperimentIdFromUrl?: string | null) {
  const { data: experimentsData, error: experimentsError } = await supabase
    .from('experiments')
    .select(`
      id,
      name,
      description,
      is_active,
      created_at,
      updated_at,
      variants (id, name, description, config_json, created_at, updated_at)
    `)
    .order('created_at', { ascending: false });

  if (experimentsError) {
    console.error('Supabase fetch experiments error:', experimentsError);
    throw new Error(experimentsError.message || 'Failed to fetch experiments.');
  }

  if (!experimentsData) return [];

  const experimentsWithStats = await Promise.all(experimentsData.map(async (exp) => {
    let variantsWithStats: Variant[] = [];
    const currentVariants = exp.variants as Variant[] | undefined || []; 
    if (currentVariants.length > 0) {
      variantsWithStats = await Promise.all(currentVariants.map(async (variant: Variant) => {
        const { count: impressionsCount, error: impressionsError } = await supabase
          .from('impressions')
          .select('*' , { count: 'exact', head: true })
          .eq('variant_id', variant.id);

        const { count: conversionsCount, error: conversionsError } = await supabase
          .from('conversions')
          .select('*' , { count: 'exact', head: true })
          .eq('variant_id', variant.id);
        
        if (impressionsError) console.error(`Error fetching impressions for variant ${variant.id}:`, impressionsError);
        if (conversionsError) console.error(`Error fetching conversions for variant ${variant.id}:`, conversionsError);

        const impressions = impressionsCount || 0;
        const conversions = conversionsCount || 0;
        const conversion_rate = impressions > 0 ? (conversions / impressions) * 100 : 0;

        return {
          ...variant,
          impressions_count: impressions,
          conversions_count: conversions,
          conversion_rate: conversion_rate
        };
      }));
    }
    return {
      ...exp,
      variants: variantsWithStats.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()), // Sort variants by creation date
      managingVariants: openExperimentIdFromUrl === exp.id, // Set based on URL param
      variantsJsonString: JSON.stringify(variantsWithStats.map(v => ({ // Pre-stringify for chart
        name: v.name,
        rate: v.conversion_rate,
        impressions: v.impressions_count,
        conversions: v.conversions_count
      })))
    };
  }));
  return experimentsWithStats;
}

// Server-side code
if (Astro.request.method === 'POST') {
  const formData = await Astro.request.formData();
  const action = formData.get('_action')?.toString();

  // Ensure session is fresh for POST actions
  const { data: { session: freshSessionOnPost } } = await supabase.auth.getSession();
  session = freshSessionOnPost;

  if (action === 'login') {
    const email = formData.get('email')?.toString();
    const password = formData.get('password')?.toString();
    if (email && password) {
      const { data, error: loginError } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      if (loginError) {
        pageError = loginError.message;
      } else if (data.session) {
        session = data.session;
        // Set a success message and redirect to clear form data and refresh state
        Astro.cookies.set('auth_message', 'Login successful!', { path: '/', maxAge: 5 }); // expires in 5s
        return Astro.redirect(Astro.url.pathname + '#user-profiles-panel', 303);
      }
    } else {
      pageError = 'Email and password are required.';
    }
  } else if (action === 'logout') {
    const { error: logoutError } = await supabase.auth.signOut();
    if (logoutError) {
      pageError = logoutError.message;
    } else {
      session = null;
      Astro.cookies.set('auth_message', 'Logout successful!', { path: '/', maxAge: 5 });
      return Astro.redirect(Astro.url.pathname, 303);
    }
  } 
  // A/B Test Actions require session
  else if (action?.startsWith('create_') || action?.startsWith('update_') || action?.startsWith('delete_')) {
    if (!session) {
      abTestError = "Authentication required. Please log in again to manage A/B tests.";
    } else {
      try {
        // Consolidate A/B test action handling here for clarity
        if (action === 'create_experiment') {
          const name = formData.get('experiment_name')?.toString();
          const description = formData.get('experiment_description')?.toString();
          const is_active = formData.get('experiment_is_active') === 'on';
          if (!name || name.trim() === '') throw new Error('Experiment name is required.');
          const { error: createExpError } = await supabase.from('experiments').insert([{ name, description, is_active }]);
          if (createExpError) throw createExpError;
          return Astro.redirect(Astro.url.pathname + '#ab-testing-panel', 303);
        }
        else if (action === 'create_variant') {
          const experimentId = formData.get('experiment_id')?.toString();
          const name = formData.get('variant_name')?.toString();
          const description = formData.get('variant_description')?.toString();
          const configJsonString = formData.get('variant_config_json')?.toString();
          if (!experimentId || !name || name.trim() === '') throw new Error('Experiment ID and Variant Name are required.');
          let config_json: VariantConfig | null = null;
          if (configJsonString && configJsonString.trim() !== '') {
            try { config_json = JSON.parse(configJsonString); } 
            catch { throw new Error('Invalid JSON for Variant Config.'); }
          }
          const { error: createVarError } = await supabase.from('variants').insert([{ experiment_id: experimentId, name, description, config_json }]);
          if (createVarError) throw createVarError;
          return Astro.redirect(Astro.url.pathname + `?openExperiment=${experimentId}#ab-testing-panel`, 303);
        }
        else if (action === 'update_experiment') {
          const experimentId = formData.get('experiment_id')?.toString();
          const name = formData.get('experiment_name')?.toString();
          const description = formData.get('experiment_description')?.toString();
          const is_active = formData.get('experiment_is_active') === 'on';
          if (!experimentId || !name || name.trim() === '') throw new Error('Experiment ID and Name required for update.');
          const { error: updateExpError } = await supabase.from('experiments').update({ name, description, is_active, updated_at: new Date().toISOString() }).eq('id', experimentId);
          if (updateExpError) throw updateExpError;
          return Astro.redirect(Astro.url.pathname + `#experiment-${experimentId}`, 303); // Go to specific experiment
        }
        else if (action === 'update_variant') {
          const experimentId = formData.get('experiment_id')?.toString(); // For redirect
          const variantId = formData.get('variant_id')?.toString();
          const name = formData.get('variant_name')?.toString();
          const description = formData.get('variant_description')?.toString();
          const configJsonString = formData.get('variant_config_json')?.toString();
          if (!variantId || !name || name.trim() === '') throw new Error('Variant ID and Name required for update.');

          const { count: impressionsCount } = await supabase.from('impressions').select('*' , { count: 'exact', head: true }).eq('variant_id', variantId);
          let newConfigJson: VariantConfig | null = null;
          if (configJsonString && configJsonString.trim() !== '') {
            try { newConfigJson = JSON.parse(configJsonString); } 
            catch { throw new Error('Invalid JSON for Variant Config.'); }
          }
          if ((impressionsCount || 0) > 0) {
            const { data: existingVariant } = await supabase.from('variants').select('config_json').eq('id', variantId).single();
            if (JSON.stringify(existingVariant?.config_json) !== JSON.stringify(newConfigJson)) {
              throw new Error('Cannot change config of variant with impressions.');
            }
          }
          const { error: updateVarError } = await supabase.from('variants').update({ name, description, config_json: newConfigJson, updated_at: new Date().toISOString() }).eq('id', variantId);
          if (updateVarError) throw updateVarError;
          return Astro.redirect(Astro.url.pathname + `?openExperiment=${experimentId}#ab-testing-panel`, 303);
        }
        else if (action === 'delete_experiment') {
          const experimentId = formData.get('experiment_id')?.toString();
          if (!experimentId) throw new Error('Experiment ID is required for deletion.');
          
          // With ON DELETE CASCADE from experiments.id to variants.experiment_id,
          // and from variants.id to impressions/conversions variant_id,
          // deleting the experiment will automatically cascade to variants, impressions, and conversions.
          // The explicit deletion of variants is no longer needed here.
          
          const { error: deleteExpError } = await supabase.from('experiments').delete().eq('id', experimentId);
          if (deleteExpError) {
            console.error('Error deleting experiment:', deleteExpError);
            // Consider how to surface this error to the user, e.g., setting abTestError
            // For now, re-throwing to be caught by the outer try-catch block.
            throw new Error(`Failed to delete experiment: ${deleteExpError.message}`);
          }
          
          return Astro.redirect(Astro.url.pathname + '#ab-testing-panel', 303);
        }
        else if (action === 'delete_variant') {
          const experimentId = formData.get('experiment_id')?.toString(); // For redirect
          const variantId = formData.get('variant_id')?.toString();
          if (!variantId) throw new Error('Variant ID is required for deletion.');
          const { count: impressionsCount } = await supabase.from('impressions').select('*' , { count: 'exact', head: true }).eq('variant_id', variantId);
          if ((impressionsCount || 0) > 0) throw new Error('Cannot delete variant with existing impressions.');
          const { error: deleteVarError } = await supabase.from('variants').delete().eq('id', variantId);
          if (deleteVarError) throw deleteVarError;
          return Astro.redirect(Astro.url.pathname + `?openExperiment=${experimentId}#ab-testing-panel`, 303);
        }
      } catch (e: unknown) {
        if (e instanceof Error) {
          abTestError = e.message;
        } else {
          abTestError = 'An unexpected error occurred during A/B test action.';
        }
        console.error('A/B Test Action Error:', e);
      }
    }
  }
}

// Fetch data on GET requests or after POST redirect
if (Astro.request.method === 'GET') {
  const { data: { session: currentSession } } = await supabase.auth.getSession();
  session = currentSession;

  const authMessage = Astro.cookies.get('auth_message');
  if (authMessage) {
    generalMessage = authMessage.value;
    Astro.cookies.delete('auth_message', { path: '/' });
  }

  if (session) {
    try {
      const { data, error: profileError } = await supabase
        .from('user_profiles')
        .select('id, email, created_at, updated_at'); // Removed last_sign_in_at
      if (profileError) throw profileError;
      userProfiles = data;
    } catch (e: unknown) {
      if (e instanceof Error) {
        pageError = e.message;
      } else {
        pageError = 'Failed to fetch user profiles due to an unexpected error.';
      }
      console.error('Fetch user profiles error:', e);
    }

    // Fetch experiments only when authenticated
    try {
      const openExperimentId = new URL(Astro.request.url).searchParams.get('openExperiment');
      experiments = await fetchExperimentsWithStats(openExperimentId);
    } catch (e: unknown) {
      if (e instanceof Error) {
        abTestError = e.message;
      } else {
        abTestError = 'Failed to fetch experiments due to an unexpected error.';
      }
      console.error('Fetch experiments error:', e);
    }
  }
}

---
<Layout metadata={metadata}>
  <div class="container mx-auto px-4 py-8 max-w-4xl">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-3xl font-bold text-slate-800 dark:text-white">Admin Dashboard</h1>
      {session && (
        <div class="flex items-center">
          <p class="text-sm text-slate-600 dark:text-slate-300 mr-3">
            Logged in as: <span class="font-semibold">{session.user.email}</span>
          </p>
          <form method="POST" action={Astro.url.pathname + '#user-profiles-panel'}> 
            <input type="hidden" name="_action" value="logout" />
            <button 
              type="submit" 
              class="px-4 py-2 text-sm font-medium tracking-wide text-white capitalize transition-colors duration-200 transform bg-red-500 rounded-md hover:bg-red-600 focus:outline-none focus:ring focus:ring-red-300 focus:ring-opacity-80"
            >
              Logout
            </button>
          </form>
        </div>
      )}
    </div>

    {/* Global Error Display - for errors not specific to a tab component, or general page errors */}
    {pageError && (
      <div class="mb-6 p-4 bg-red-100 dark:bg-red-800/30 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-300 rounded-lg shadow-sm" role="alert">
        <p class="font-bold text-lg">Error:</p>
        <p>{pageError}</p>
      </div>
    )}
    {/* General Message Display - for login/logout success etc */}
    {generalMessage && (
      <div class="mb-6 p-4 bg-green-100 dark:bg-green-800/30 border border-green-400 dark:border-green-600 text-green-700 dark:text-green-300 rounded-lg shadow-sm" role="alert">
        <p>{generalMessage}</p>
      </div>
    )}

    {/* Show tabs only when authenticated */}
    {session && (
      <div class="mb-8">
        <div class="sm:hidden">
          <label for="tabs" class="sr-only">Select a tab</label>
          <select id="tabs" name="tabs" class="block w-full rounded-md border-gray-300 focus:border-blue-500 focus:ring-blue-500 dark:bg-slate-700 dark:border-slate-600 dark:text-white">
            <option selected>A/B Testing</option>
            <option>User Profiles</option>
          </select>
        </div>
        <div class="hidden sm:block">
          <div class="border-b border-slate-200 dark:border-slate-700">
            <nav class="-mb-px flex space-x-4" aria-label="Tabs">
              <a href="#ab-testing-panel" id="ab-testing-tab" 
                 class="tab-button active-tab group whitespace-nowrap py-3 px-3 border-b-2 font-medium text-sm flex items-center"
                 aria-current="page">
                <svg class="-ml-0.5 mr-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M7.5 5a2.5 2.5 0 00-4.995.088A2.5 2.5 0 002.5 7.5v5A2.5 2.5 0 005 15h10a2.5 2.5 0 002.5-2.5v-5A2.5 2.5 0 0015 5H7.5zM5 7.5a.5.5 0 01.5-.5h1.086A.5.5 0 017 7.5v5a.5.5 0 01-.5.5H5.5a.5.5 0 01-.5-.5v-5zm9.5 0a.5.5 0 00-.5-.5H13A.5.5 0 0012.5 7.5v5a.5.5 0 00.5.5h1.086A.5.5 0 00.414-.75L13.5 9.5l1.414-2.75A.5.5 0 0014.5 7.5z" clip-rule="evenodd" /></svg>
                <span>A/B Testing</span>
              </a>
              <a href="#user-profiles-panel" id="user-profiles-tab"
                 class="tab-button group whitespace-nowrap py-3 px-3 border-b-2 font-medium text-sm flex items-center"
                 aria-current="false">
                <svg class="-ml-0.5 mr-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z" /></svg>
                <span>User Profiles</span>
              </a>
            </nav>
          </div>
        </div>
      </div>
    )}
    
    {/* Content: Login form for unauthenticated, dashboard for authenticated */}
    {!session ? (
      /* Show login form when not authenticated */
      <div class="max-w-md mx-auto mt-12 bg-white dark:bg-slate-800 shadow-xl rounded-lg p-8">
        <h3 class="text-2xl font-semibold text-center text-slate-700 dark:text-slate-200 mb-6">Admin Login Required</h3>
        <p class="text-center text-slate-600 dark:text-slate-400 mb-6">
          Please log in to access the admin dashboard and manage A/B tests.
        </p>
        <form method="POST" action={Astro.url.pathname} class="space-y-6">
          <input type="hidden" name="_action" value="login" />
          <div>
            <label for="email" class="block text-sm font-medium text-slate-700 dark:text-slate-300">Email Address</label>
            <input
              id="email"
              name="email"
              type="email"
              autocomplete="email"
              required
              class="mt-1 block w-full shadow-sm appearance-none border border-slate-300 dark:border-slate-600 rounded-md py-2.5 px-3 text-slate-700 dark:text-slate-200 bg-white dark:bg-slate-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 placeholder-slate-400 dark:placeholder-slate-500"
            />
          </div>
          <div>
            <label for="password" class="block text-sm font-medium text-slate-700 dark:text-slate-300">Password</label>
            <input
              id="password"
              name="password"
              type="password"
              autocomplete="current-password"
              required
              class="mt-1 block w-full shadow-sm appearance-none border border-slate-300 dark:border-slate-600 rounded-md py-2.5 px-3 text-slate-700 dark:text-slate-200 bg-white dark:bg-slate-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 placeholder-slate-400 dark:placeholder-slate-500"
            />
          </div>
          <button
            type="submit"
            class="w-full flex justify-center py-2.5 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-slate-900 focus:ring-blue-500 transition duration-150 ease-in-out"
          >
            Sign In
          </button>
        </form>
      </div>
    ) : (
      /* Show admin dashboard when authenticated */
      <>
        {/* Tab Panels */}
        <div id="ab-testing-panel" role="tabpanel" class="tab-panel pt-6">
          <ABTestManager experiments={experiments} abTestError={abTestError} />
        </div>

        <div id="user-profiles-panel" role="tabpanel" class="tab-panel pt-6 hidden">
          <UserProfileManager userProfiles={userProfiles} userProfilesError={pageError} isUserLoggedIn={!!session} />
        </div>
      </>
    )}
    
  </div> {/* End of container div with mx-auto etc. */}

</Layout>

<style>
  .tab-button {
    @apply border-transparent text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-300 hover:border-slate-300 dark:hover:border-slate-500;
  }
  .tab-button.active-tab {
    @apply border-blue-500 text-blue-600 dark:text-blue-400 dark:border-blue-400;
  }
  .tab-button svg {
    @apply text-slate-400 group-hover:text-slate-500 dark:text-slate-500 dark:group-hover:text-slate-400;
  }
  .tab-button.active-tab svg {
    @apply text-blue-500 dark:text-blue-400;
  }
  /* .tab-panel no longer needs border/shadow/rounded if tabs are underlined style */
</style>

<script>
  // Client-side script for tab navigation
  function initializeTabs() {
    const tabs = document.querySelectorAll('.tab-button');
    const panels = document.querySelectorAll('.tab-panel');
    
    // Only initialize tabs if they exist (i.e., user is authenticated)
    if (tabs.length === 0 || panels.length === 0) {
      console.log("Dashboard: No tabs found, skipping tab initialization (user likely not authenticated)");
      return;
    }

    const setActiveTab = (targetId: string) => {
      tabs.forEach(tab => {
        const tabElement = tab as HTMLAnchorElement;
        if (tabElement.hash === targetId) {
          tabElement.classList.add('active-tab');
          tabElement.setAttribute('aria-selected', 'true');
        } else {
          tabElement.classList.remove('active-tab');
          tabElement.setAttribute('aria-selected', 'false');
        }
      });

      panels.forEach(panel => {
        const panelElement = panel as HTMLElement;
        if (`#${panelElement.id}` === targetId) {
          panelElement.classList.remove('hidden');
        } else {
          panelElement.classList.add('hidden');
        }
      });
      // Update URL hash without page jump
      if (history.pushState) {
        history.pushState(null, '', targetId);
      } else {
        location.hash = targetId;
      }
    };

    tabs.forEach(tab => {
      tab.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = (e.currentTarget as HTMLAnchorElement).hash;
        setActiveTab(targetId);
        
        // If A/B testing tab is now active, and an experiment was opened, clear the openExperiment query param
        // to avoid it persisting if user navigates away and back to this tab manually.
        if (targetId === '#ab-testing-panel') {
            const currentUrl = new URL(window.location.href);
            if (currentUrl.searchParams.has('openExperiment')) {
                currentUrl.searchParams.delete('openExperiment');
                window.history.replaceState({ path: currentUrl.href }, '', currentUrl.pathname + currentUrl.search + currentUrl.hash);
            }
        }
      });
    });

    // Set initial tab based on URL hash or default to A/B testing
    let initialTabId = window.location.hash;
    if (!initialTabId || (initialTabId !== '#ab-testing-panel' && initialTabId !== '#user-profiles-panel')) {
      initialTabId = '#ab-testing-panel';
    }
    setActiveTab(initialTabId);
    
    // If opening page with ?openExperiment query param, ensure A/B tab is active
    const params = new URLSearchParams(window.location.search);
    if (params.has('openExperiment')) {
        setActiveTab('#ab-testing-panel');
        // Scroll to the specific experiment if its ID is in the hash (e.g. from form redirect)
        // This part is a bit tricky because the experiment div might not be immediately available if data is still loading
        // The #experiment-id part of the URL hash will be handled by the browser naturally if the element exists.
    }

  }

  // Initialize tabs on initial page load and after Astro view transitions
  document.addEventListener('astro:page-load', () => {
    console.log("Dashboard astro:page-load: Initializing tabs...");
    initializeTabs();
    // The ABTestManager component also has its own 'astro:page-load' listener for its specific scripts (charts, toggles).
    // No need to explicitly call its init function here, Astro handles it.
  });

  // Handle popstate for browser back/forward for tabs
  window.addEventListener('popstate', () => {
    // Only handle tab navigation if tabs exist (user is authenticated)
    const tabs = document.querySelectorAll('.tab-button');
    if (tabs.length === 0) {
      console.log("Dashboard: No tabs found on popstate, skipping tab navigation");
      return;
    }
    
    let hash = window.location.hash;
    if (!hash || (hash !== '#ab-testing-panel' && hash !== '#user-profiles-panel')) {
      hash = '#ab-testing-panel'; // Default to A/B tab
    }
    // initializeTabs() already contains setActiveTab which reads the hash.
    // So, re-initializing tabs should correctly set the active tab based on the new hash.
    initializeTabs();
  });

</script> 